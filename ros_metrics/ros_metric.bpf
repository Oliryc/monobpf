#define KBUILD_MODNAME "foo"
#include <uapi/linux/bpf.h>
#include <net/sock.h>
#include <bcc/proto.h>
#include <linux/in.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <linux/if_vlan.h>
#include <linux/ip.h>
#include <linux/ipv6.h>


#define IP_TCP 6
#define ETH_HLEN 14
#define ROS_MASTER_PORT 11311

BPF_ARRAY(headers,u64,256);
//This should be optimized better probably
BPF_ARRAY(head_size,u64,1);
BPF_ARRAY(topics,u64,1);

struct Key {
	u32 src_ip;               //source ip
	u32 dst_ip;               //destination ip
	unsigned short src_port;  //source port
	unsigned short dst_port;  //destination port
};

struct Leaf {
	int allow;            //timestamp in ns
};

//BPF_TABLE(map_type, key_type, leaf_type, table_name, num_entry)
//map <Key, Leaf>
//tracing sessions having same Key(dst_ip, src_ip, dst_port,src_port)
BPF_HASH(sessions, struct Key, struct Leaf, 1024);

int session_monitor(struct CTXTYPE *ctx) {
    void* data_end = (void*)(long)ctx->data_end;
    void* data = (void*)(long)ctx->data;
    struct Key auth_key;
    struct Leaf auth_leaf;
    struct ethhdr *eth_hdr;
    struct iphdr* ip_hdr;
    struct tcphdr* tcp_hdr;
    uint32_t hs_key =0;
    uint32_t head_key =0;
    uint32_t tot_len = 0;
    long *hs_value;
    long *head_value;
    auth_leaf.allow = 0;
    eth_hdr = (struct ethhdr *)data;

    // drop packets
    int rc = RETURNCODE; // let pass XDP_PASS or redirect to tx via XDP_TX
    ip_hdr = (struct iphdr *)(eth_hdr + 1);
    if (ip_hdr + 1 > (struct iphdr *)data_end) {
        bpf_trace_printk("=== Abort 2\n");
        return XDP_PASS;
    }
    tcp_hdr = (struct tcphdr*)((u8 *)ip_hdr + ip_hdr->ihl * 4);
    if (tcp_hdr + 1 > (struct tcphdr *)data_end) {
        bpf_trace_printk("=== Abort 3\n");
        return XDP_PASS;
    }
    bpf_trace_printk("TCP SRC IP: %d", ip_hdr->saddr);
    bpf_trace_printk(" PORT%d\n", bpf_ntohs(tcp_hdr->source));
    bpf_trace_printk("TCP DEST IP: %d", ip_hdr->daddr);
    bpf_trace_printk(" PORT%d\n", bpf_ntohs(tcp_hdr->dest));
    //TODO: METADATA
    auth_key.src_ip = ip_hdr->saddr;
    auth_key.src_port = bpf_ntohs(tcp_hdr->source);
    auth_key.dst_ip = ip_hdr->daddr;
    auth_key.dst_port = bpf_ntohs(tcp_hdr->dest);


    //TODO: take ROS_MASTER FROM AN ARG
    if (auth_key.src_port == ROS_MASTER_PORT || auth_key.dst_port == ROS_MASTER_PORT){
       auth_leaf.allow = 1;
    }

    sessions.insert(&auth_key, &auth_leaf);
    tot_len = bpf_ntohs(ip_hdr->tot_len);
    bpf_trace_printk("ip_hdr->tot_len1: %u\n", tot_len);
      u16 tcphdr_length = tcp_hdr->doff;
    char *http_hdr = (char *)((u8 *)tcp_hdr + tcphdr_length * 4);
    char *http_hdr2 = (char *)((u32 *)tcp_hdr + 8);
    /*bpf_trace_printk("data: %p\n", data);
    bpf_trace_printk("eth_hdr: %p\n", eth_hdr);
    bpf_trace_printk("ip_hdr: %p\n", ip_hdr);
    bpf_trace_printk("ip_hdr->tot_len: %u\n", bpf_ntohs(ip_hdr->tot_len));
    bpf_trace_printk("tcp_hdr: %p\n", tcp_hdr);
    bpf_trace_printk("http_hdr1: %p\n", http_hdr);
    bpf_trace_printk("http_hdr2: %p\n", http_hdr2);
    bpf_trace_printk("http_hdr-tcp_hdr: %u\n", http_hdr-(char *)tcp_hdr);
    bpf_trace_printk("http_hdr2-tcp_hdr: %u\n", http_hdr2-(char *)((u32 *)tcp_hdr));
    bpf_trace_printk("data_end : %p\n", data_end);
    bpf_trace_printk("data_end-data : %u\n", (data_end-data));
    bpf_trace_printk("header_size(byte) : %u\n", sizeof(struct tcphdr)+sizeof(struct iphdr)+sizeof(struct ethhdr));
    bpf_trace_printk("==============================\n");
    */
    
    hs_value = head_size.lookup(&hs_key);
    if (!hs_value){
        bpf_trace_printk("Error, failed to look up hs_value\n");
        return XDP_PASS;
    }
    head_key = *hs_value;
    head_value = headers.lookup(&head_key);
    if (!head_value){
        bpf_trace_printk("Error, failed to look up head_value\n");
        return XDP_PASS;
    }

    if (ip_hdr->tot_len > 80){
        bpf_trace_printk("Adding a packet to the list: %u\n", tcp_hdr->seq);
        *head_value = tcp_hdr->seq;
        *hs_value+=1;
    }
    if (*hs_value > 255){
        bpf_trace_printk("Error Head Size exceeded array size. Data was lost!\n");
        *hs_value = 0;
    }

    return rc;

}
