#define KBUILD_MODNAME "foo"
#include <uapi/linux/bpf.h>
#include <linux/in.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <linux/if_vlan.h>
#include <linux/ip.h>
#include <linux/ipv6.h>

BPF_ARRAY(headers,u64,256);
//This should be optimized better probably
BPF_ARRAY(head_size,u64,1);
BPF_ARRAY(topics,u64,1);

struct Key {
	u32 src_ip;               //source ip
	u32 dst_ip;               //destination ip
	unsigned short src_port;  //source port
	unsigned short dst_port;  //destination port
};

struct Leaf {
	int allow;            //timestamp in ns
};

#define ROS_MASTER_PORT 11311
//BPF_TABLE(map_type, key_type, leaf_type, table_name, num_entry)
//map <Key, Leaf>
//tracing sessions having same Key(dst_ip, src_ip, dst_port,src_port)
BPF_HASH(sessions, struct Key, struct Leaf, 1024);

int session_monitor(struct __sk_buff *skb) {
    u8 *cursor = 0;

	struct ethernet_t *ethernet = cursor_advance(cursor, sizeof(*ethernet));
	//filter IP packets (ethernet type = 0x0800)
	if (!(ethernet->type == 0x0800)) {
		goto DROP;
	}

	struct ip_t *ip = cursor_advance(cursor, sizeof(*ip));
	//filter TCP packets (ip next protocol = 0x06)
	if (ip->nextp != IP_TCP) {
		goto DROP;
	}

	u32  tcp_header_length = 0;
	u32  ip_header_length = 0;
	u32  payload_offset = 0;
	u32  payload_length = 0;
	struct Key 	auth_key;
	struct Leaf auth_leaf = {0};

        //calculate ip header length
        //value to multiply * 4
        //e.g. ip->hlen = 5 ; IP Header Length = 5 x 4 byte = 20 byte
        ip_header_length = ip->hlen << 2;    //SHL 2 -> *4 multiply

        //check ip header length against minimum
        if (ip_header_length < sizeof(*ip)) {
                goto DROP;
        }

        //shift cursor forward for dynamic ip header size
        void *_ = cursor_advance(cursor, (ip_header_length-sizeof(*ip)));

	struct tcp_t *tcp = cursor_advance(cursor, sizeof(*tcp));

	//retrieve ip src/dest and port src/dest of current packet
	//and save it into struct Key
	key.dst_ip = ip->dst;
	key.src_ip = ip->src;
	key.dst_port = tcp->dst_port;
	key.src_port = tcp->src_port;

	//calculate tcp header length
	//value to multiply *4
	//e.g. tcp->offset = 5 ; TCP Header Length = 5 x 4 byte = 20 byte
	tcp_header_length = tcp->offset << 2; //SHL 2 -> *4 multiply

	//calculate payload offset and length
	payload_offset = ETH_HLEN + ip_header_length + tcp_header_length;
	payload_length = ip->tlen - ip_header_length - tcp_header_length;

	//http://stackoverflow.com/questions/25047905/http-request-minimum-size-in-bytes
	//minimum length of http request is always geater than 7 bytes
	//avoid invalid access memory
	//include empty payload
	if(payload_length < 7) {
		goto DROP;
	}

	//load first 7 byte of payload into p (payload_array)
	//direct access to skb not allowed
	unsigned long p[7];
	int i = 0;
	for (i = 0; i < 7; i++) {
		p[i] = load_byte(skb , payload_offset + i);
	}

	//find a match with an HTTP message
	//HTTP
	if ((p[0] == 'H') && (p[1] == 'T') && (p[2] == 'T') && (p[3] == 'P')) {
		goto HTTP_MATCH;
	}
	//GET
	if ((p[0] == 'G') && (p[1] == 'E') && (p[2] == 'T')) {
		goto HTTP_MATCH;
	}
	//POST
	if ((p[0] == 'P') && (p[1] == 'O') && (p[2] == 'S') && (p[3] == 'T')) {
		goto HTTP_MATCH;
	}
	//PUT
	if ((p[0] == 'P') && (p[1] == 'U') && (p[2] == 'T')) {
		goto HTTP_MATCH;
	}
	//DELETE
	if ((p[0] == 'D') && (p[1] == 'E') && (p[2] == 'L') && (p[3] == 'E') && (p[4] == 'T') && (p[5] == 'E')) {
		goto HTTP_MATCH;
	}
	//HEAD
	if ((p[0] == 'H') && (p[1] == 'E') && (p[2] == 'A') && (p[3] == 'D')) {
		goto HTTP_MATCH;
	}

	//no HTTP match
	//check if packet belong to an HTTP session
    bpf_trace_printk("TCP SRC IP: %d", ip_hdr->saddr);
    bpf_trace_printk(" PORT%d\n", bpf_ntohs(tcp_hdr->source));
    bpf_trace_printk("TCP DEST IP: %d", ip_hdr->daddr);
    bpf_trace_printk(" PORT%d\n", bpf_ntohs(tcp_hdr->dest));
    //TODO: METADATA
    auth_key.src_ip = ip_hdr->saddr;
    auth_key.src_port = bpf_ntohs(tcp_hdr->source);
    auth_key.dst_ip = ip_hdr->daddr;
    auth_key.dst_port = bpf_ntohs(tcp_hdr->dest);


    //TODO: take ROS_MASTER FROM AN ARG
    if (auth_key.src_port == ROS_MASTER_PORT || auth_key.dst_port == ROS_MASTER_PORT){
       auth_leaf.allow = 1;
    }

    sessions.insert(&auth_key, &auth_leaf);

	//keep the packet and send it to userspace retruning -1
	HTTP_MATCH:
	//if not already present, insert into map <Key, Leaf>
	sessions.lookup_or_init(&key,&zero);

	//send packet to userspace returning -1
	KEEP:
	return -1;

	//drop the packet returning 0
	DROP:
	return 0;
   /* void* data_end = (void*)(long)ctx->data_end;
    void* data = (void*)(long)ctx->data;
    struct Key auth_key;
    struct Leaf auth_leaf;
    struct ethhdr *eth_hdr;
    struct iphdr* ip_hdr;
    struct tcphdr* tcp_hdr;
    uint32_t hs_key =0;
    uint32_t head_key =0;
    uint32_t tot_len = 0;
    long *hs_value;
    long *head_value;
    auth_leaf.allow = 0;
    eth_hdr = (struct ethhdr *)data;

    // drop packets
    int rc = RETURNCODE; // let pass XDP_PASS or redirect to tx via XDP_TX
    ip_hdr = (struct iphdr *)(eth_hdr + 1);
    if (ip_hdr + 1 > (struct iphdr *)data_end) {
        bpf_trace_printk("=== Abort 2\n");
        return XDP_PASS;
    }
    tcp_hdr = (struct tcphdr*)((u8 *)ip_hdr + ip_hdr->ihl * 4);
    if (tcp_hdr + 1 > (struct tcphdr *)data_end) {
        bpf_trace_printk("=== Abort 3\n");
        return XDP_PASS;
    }
    bpf_trace_printk("TCP SRC IP: %d", ip_hdr->saddr);
    bpf_trace_printk(" PORT%d\n", bpf_ntohs(tcp_hdr->source));
    bpf_trace_printk("TCP DEST IP: %d", ip_hdr->daddr);
    bpf_trace_printk(" PORT%d\n", bpf_ntohs(tcp_hdr->dest));
    //TODO: METADATA
    auth_key.src_ip = ip_hdr->saddr;
    auth_key.src_port = bpf_ntohs(tcp_hdr->source);
    auth_key.dst_ip = ip_hdr->daddr;
    auth_key.dst_port = bpf_ntohs(tcp_hdr->dest);


    //TODO: take ROS_MASTER FROM AN ARG
    if (auth_key.src_port == ROS_MASTER_PORT || auth_key.dst_port == ROS_MASTER_PORT){
       auth_leaf.allow = 1;
    }

    sessions.insert(&auth_key, &auth_leaf);
    hs_value = head_size.lookup(&hs_key);
    if (!hs_value){
        bpf_trace_printk("Error, failed to look up hs_value\n");
        return XDP_PASS;
    }
    head_key = *hs_value;
    head_value = headers.lookup(&head_key);
    if (!head_value){
        bpf_trace_printk("Error, failed to look up head_value\n");
        return XDP_PASS;
    }
    tot_len = bpf_ntohs(ip_hdr->tot_len);
    bpf_trace_printk("ip_hdr->tot_len1: %u\n", tot_len);


    if (ip_hdr->tot_len > 80){
        bpf_trace_printk("Adding a packet to the list: %u\n", tcp_hdr->seq);
        *head_value = tcp_hdr->seq;
        *hs_value+=1;
    }
    if (*hs_value > 255){
        bpf_trace_printk("Error Head Size exceeded array size. Data was lost!\n");
        *hs_value = 0;
    }

    return rc;
    */
}
